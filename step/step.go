package step

import (
	"bytes"
	"fmt"
	"regexp"
	"text/template"

	"github.com/bitrise-io/go-steputils/v2/stepconf"
	"github.com/bitrise-io/go-utils/v2/env"
	"github.com/bitrise-io/go-utils/v2/log"
)

type Input struct {
	Verbose bool `env:"verbose,required"`

	Model        string          `env:"openai_model,required"`
	OpenAIApiKey stepconf.Secret `env:"openai_api_key,required"`

	GitHubToken stepconf.Secret `env:"github_token,required"`
	PRID        int             `env:"pr_id"`
	RepoOwner   string          `env:"repo_owner"`
	RepoName    string          `env:"repo_name"`

	PRTitle          string `env:"pr_title"`
	PRDescription    string `env:"pr_description"`
	RepoDescription  string `env:"repo_description"`
	PRDetailTemplate string `env:"pr_detail_template,required"`
	SystemPrompt     string `env:"system_prompt,required"`
}

type CodeReviewStep struct {
	logger      log.Logger
	inputParser stepconf.InputParser
	envRepo     env.Repository
}

type PRPromptInventory struct {
	PRTitle          string
	PRDescription    string
	RepoDescription  string
	RepoMainLanguage string
}

func New(
	logger log.Logger,
	inputParser stepconf.InputParser,
	envRepo env.Repository,
) CodeReviewStep {
	return CodeReviewStep{
		logger:      logger,
		inputParser: inputParser,
		envRepo:     envRepo,
	}
}

func (step CodeReviewStep) Run() error {
	var input Input
	if err := step.inputParser.Parse(&input); err != nil {
		return fmt.Errorf("failed to parse inputs: %w", err)
	}
	stepconf.Print(input)
	step.logger.Println()

	step.logger.EnableDebugLog(input.Verbose)

	step.logger.Infof("Fetching PR details...")
	ghClient := NewGitHubClient(string(input.GitHubToken), input.RepoOwner, input.RepoName, input.PRID)
	prData, err := ghClient.PullRequest(input.PRID)
	if err != nil {
		return fmt.Errorf("failed to get PR data: %w", err)
	}

	step.logger.Printf("Repo description: %s", prData.GetBase().GetRepo().GetDescription())
	step.logger.Printf("Repo main language: %s", prData.GetBase().GetRepo().GetLanguage())
	step.logger.Printf("PR title: %s", prData.GetTitle())
	if len(prData.GetBody()) > 100 {
		step.logger.Printf("PR description: %s...", prData.GetBody()[:100])
	} else {
		step.logger.Printf("PR description: %s", prData.GetBody())
	}
	step.logger.Donef("Done.")

	templateInventory := PRPromptInventory{
		PRTitle:          prData.GetTitle(),
		PRDescription:    prData.GetBody(),
		RepoDescription:  prData.GetBase().GetRepo().GetDescription(),
		RepoMainLanguage: prData.GetBase().GetRepo().GetLanguage(),
	}
	prompt, err := step.RenderPRPrompt(input.PRDetailTemplate, templateInventory)
	if err != nil {
		return fmt.Errorf("failed to render PR prompt: %w", err)
	}

	client := NewOpenAIClient(string(input.OpenAIApiKey), input.Model, step.logger)
	step.logger.Infof("Generating response...")
	completion, err := client.GetCompletion(input.SystemPrompt, prompt)
	if err != nil {
		return err
	}

	step.logger.Donef("%s", completion)

	hasLink, err := textHasMarkdownLink(completion)
	if err != nil {
		return fmt.Errorf("failed to check if completion has link: %w", err)
	}
	if hasLink {
		step.logger.Errorf("Completion contains an external link. To avoid a possible prompt injection and phishing attack, the output will not be posted as a comment.")
		return nil
	}

	step.logger.Infof("Posting PR comment...")
	commentBody, err := step.renderPRComment(completion)
	if err != nil {
		return fmt.Errorf("failed to render PR comment: %w", err)
	}
	comment, err := ghClient.UpsertComment(commentBody)
	if err != nil {
		return fmt.Errorf("failed to post comment: %w", err)
	}

	step.logger.Donef("Comment posted")
	step.logger.Infof(comment.GetHTMLURL())

	return nil
}

func (step CodeReviewStep) RenderPRPrompt(detailTemplate string, inventory PRPromptInventory) (string, error) {
	tmpl, err := template.New("pr_details").Parse(detailTemplate)
	if err != nil {
		return "", fmt.Errorf("error creating template: %w", err)
	}

	resultBuffer := bytes.Buffer{}
	err = tmpl.Execute(&resultBuffer, inventory)
	if err != nil {
		return "", fmt.Errorf("error executing template: %w", err)
	}

	return resultBuffer.String(), nil
}

func (step CodeReviewStep) renderPRComment(completion string) (string, error) {
	tmplText := `**CodeReviewGPT had a look at this PR and has the following comments:**

{{ .Completion }}

---
_These questions are generated by a large language model. Please note that the model doesn't have a deep understanding of this codebase and the questions are not always relevant. Please use your best judgement when answering or ignoring these questions. This notice was also written by a large language model :)_`

	type Inventory struct {
		Completion string
	}

	tmpl, err := template.New("pr_comment").Parse(tmplText)
	if err != nil {
		return "", fmt.Errorf("error creating template: %w", err)
	}
	resultBuffer := bytes.Buffer{}
	err = tmpl.Execute(&resultBuffer, Inventory{Completion: completion})
	if err != nil {
		return "", fmt.Errorf("error executing template: %w", err)
	}

	return resultBuffer.String(), nil
}

func textHasMarkdownLink(text string) (bool, error) {
	return regexp.MatchString(`^\[([\w\s\d]+)\]\((https?:\/\/[\w\d./?=#]+)\)$`, text)
}
